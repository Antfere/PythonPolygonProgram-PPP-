# Program which lets users input a minimum of 3 points on a positive coordinate plane
# Program will then connect each point in chronological order with a line creating a polygon
# If a point is already on the line created by the two points infront and behind it it will simply be removed
# If a point would create an intersection with a previous line the user is not allowed to input it
# The last line will be automatically generated by the program by connecting the first and last coordinate. If this is impossible then the user will be prompted.
# Program will then allow the user to choose a point on the coordinate plane
# Finally the program will tell the user if the point is on the edges of the polygon, inside, or outside of the polygon

# Points will be simple x,y coordinates, no complex numbers or vectors
# Lines will be functions with either inequalities to bound them or just a simple check, or are those the same thing programatically?
# A point will be on the edges of the polygon if it is on one of the line equations or inbetween two points on the same slope, or simply on a vertex
# A point can be considered inside if it takes an odd amount of "crosses" to escape the polygon and reach the maximal bounding box of the polygon, or some very high number
# A point can be considered outside if it takes an even (including 0) amount of "crosses" to escape the polygon and reach the maximal bounding box, or some very high number

# Bounding box is defined as the minimum and maximum x and y coordinates plus and minus

# Programmatic function of a bounded line: f(min_x <= x <= max_x) = ax + b
# a can be found using the slope equation of the two points
# b can be found by isolating the equation around x = 0
# Min and max bounds can be found using the points used to make the line

# Intersection of point and line:
# First check if the inputted x of a point is inbetween or equal to min_x and max_x
# If true, check if the output of a(x) + b is equal to the y coordinate
# If slope is infinity, as in the line is vertical, then instead find x when y is restricted and see if it conforms to the point x

# "Escape rays" can be defined as a random slope value centered on the chosen point, with an inequality forcing the right direction
# Random slope value can be obtained by randomly choosing a number between -1 and +1 twice to create a new coordinate
# Then this coordinate and the original chosen point can have the slope equation applied, then inequality is picked

# Intersection of line and line or escape ray and line:
# Divide y_1 by y_2 from the points to get y_3. Multiply y_2 and it's equation ax_2 + b by y_3
# Substract all first terms by second terms and isolate for x programatically
# Then find y with x, and double check using both equations
# If an error occurs just assume the lines don't cross and continue
# If division by zero error specifically then it's probably a overlapping error I think, just reroll

# There is one limitation, I don't know what to do if the escape ray crosses a vertex
# My only solution is to reroll the ray infinitely many times until it dosen't cross any vertices
# This will lead to a performance hit if the polygon is increasingly circular or overlapping, but who would do that?

# Another small limitation is if the escape ray overlaps perfectly a edge line.
# This is not as bad as it should be impossible to make every degree overlapping even with an infinite amount of vertices
# Simply because to make slopes parralel to a points rays at all angles would require each point to be shifted slightly, which would create gaps
# Solution: Just reroll

# Desmos test polygon and test points reference: https://www.desmos.com/calculator/otywogr6xv

# Needed for raygen
import random

coordinateList = []
lineList = []
inputting = True

# Bounding Box class to make special bounds that house the polygon
class BoundingBox():
    def __init__(self, coordinateList):
        tempx = []
        tempy = []
        for i in coordinateList:
            tempx.append(i.x)
            tempy.append(i.y)
        
        self.horizontalBounds = min(tempx) - 1, max(tempx) + 1
        self.verticalBounds = min(tempy) - 1, max(tempy) + 1

# Coordinate class with x and y parts
class Coordinate():
    def __init__(self, x, y):
        self.x = float(x)
        self.y = float(y)

# Line class with slope, y intercept if slope is non infinite, x intercept if slope is infinite, 
# optional direction (For differentiating rays from lines), Bound type, and bounds (inequality)
# and optional pre defined bounding box bounds for bounding boxes
class Line():
    def __init__(self, x_1, y_1, x_2, y_2, direction="", presetBounds=""):
        if x_2 != x_1:
            self.slope = (float(y_2) - float(y_1))/(float(x_2) - float(x_1))
            # This is an y intercept
            self.intercept = -(self.slope*float(x_1) - float(y_1))
            
        else:
            self.slope = "infinity"
            # This is an x intercept
            self.intercept = x_1
            
        if self.slope == "infinity":
            self.boundType = "y"
            if direction == 1:
                self.bounds = float(y_1), presetBounds.verticalBounds[1]
            if direction == 0:
                self.bounds = presetBounds.verticalBounds[0], float(y_1)
            if direction == "":
                self.bounds = float(y_1), float(y_2)
        else:
            self.boundType = "x"
            if direction == 1:
                self.bounds = float(x_1), presetBounds.horizontalBounds[1]
            if direction == 0:
                self.bounds = presetBounds.horizontalBounds[0], float(x_1)
            if direction == "":
                self.bounds = float(x_1), float(x_2)

# Invalid format error
class invalidCoordFormatError(Exception):
    pass

# Cord gen function for error handling before object creation without breaking while loop
# I could have a coordinate intersection check here
def coordGen():
    try:
        coordinateString = input("Coordinate: ").split(" ")
        # For the prebuilt test
        if coordinateString[0] == "test":
            return "prebuiltTest"
        # Make sure at least three vertices, if true then return the polygon quit command
        if coordinateString[0] == "q":
            if len(coordinateList) < 3:
                print("Minimum of three Coordinates")
                startPolygon(coordinateList, lineList)
            # Moves on to choose point function
            return "q"
        
        # Raises formatting errors in coordinate input and let's the user retry
        if len(coordinateString) != 2:
            raise invalidCoordFormatError("Enter only 2 numbers (1 space delimeter) per coord.")
        try:
            if (((float(coordinateString[0]) > 0) == False) or ((float(coordinateString[1]) > 0) == False)):
                raise invalidCoordFormatError("Enter only positive integers and decimals")
        except ValueError:
            raise invalidCoordFormatError("Enter only positive integers and decimals")

        # Once all checks are done on the string a preemptive coordinate is created
        tempCoordinate = Coordinate(coordinateString[0], coordinateString[1])

        # When choosing point
        if inputting == False:
            return tempCoordinate

        # Starts counting for every index after the first
        # Ensures that every coordinate but the first cannot be the same
        # Combined with the next block it will ensure that the user cannot have two same coordinates,
        # except in cases where the user wants to "complete" his polygon by making the last coordinate also the first
        for vertex in coordinateList[1:]:
            if ((tempCoordinate.x == vertex.x) and (tempCoordinate.y == vertex.y)):
                print("Two coordinates cannot be the same")
                return coordinateList
        
        if (len(coordinateList) == 1):
            if ((tempCoordinate.x == coordinateList[0].x) and (tempCoordinate.y == coordinateList[0].y)):
                print("Two coordinates cannot be the same")
                return coordinateList

        # If all checks pass it's a normal coordinate and can be added to the list
        coordinateList.append(tempCoordinate)
        return coordinateList

    # Generic error return blank
    except invalidCoordFormatError as e:
        print(f"Wrong coord format: {e}")
        return []

# Line gen function for making sure cord lists have more then 1 entry
def lineGen(Coordinates, end):
    # For the last line between start and finish after the user inputs "q"
    if end == True:
        # If the user decided to "draw the lines" instead of inputting all vertices then the program will still work fine
        if ((Coordinates[-1].x == Coordinates[0].x) and (Coordinates[-1].y == Coordinates[0].y)):
            coordinateList.pop()
        # If the user decides to input all vertices instead of "drawing the lines" the program will complete the last polygon line by itself
        else:
            tempLine = Line(Coordinates[-1].x, Coordinates[-1].y, Coordinates[0].x, Coordinates[0].y, "")
            # Makes sure there is no intersection between the last generated line and all other objects
            if not (((intersectionCheck(tempLine, lineList) > 0) or (((intersectionCheck(tempLine, coordinateList) > 0))))):
                lineList.append(tempLine)
                print(lineList[-1].slope)
                print(lineList[-1].intercept)
                print(lineList[-1].boundType)
                print(lineList[-1].bounds)
            else:
                print("Intersection detected, please make sure that when you quit the line between your first and last entered coordinates is valid")
                coordinateList.pop()
                startPolygon(coordinateList, lineList)
    else:
        # Similar to above block but only when dealing with coordinates inbetween first and last
        if len(Coordinates) > 1:
            tempLine = Line(Coordinates[-2].x, Coordinates[-2].y, Coordinates[-1].x, Coordinates[-1].y, "")
            if len(lineList) > 0:
                if not (((intersectionCheck(tempLine, lineList) > 0) or (((intersectionCheck(tempLine, coordinateList) > 0))))):
                    lineList.append(tempLine)
                    print(lineList[-1].slope)
                    print(lineList[-1].intercept)
                    print(lineList[-1].boundType)
                    print(lineList[-1].bounds)
                else:
                    print("Intersection detected, last entered coordinates removed")
                    coordinateList.pop()
            else:
                lineList.append(tempLine)
                print(lineList[-1].slope)
                print(lineList[-1].intercept)
                print(lineList[-1].boundType)
                print(lineList[-1].bounds)

# Starting function, splits between making the polygon and testing the points
def startPolygon(coordinateList, lineList):
    # Have to declare global variable usage here to then be able to change it globally in the function with while loop
    global inputting
    global temp
    # While in polygon build mode
    while inputting:

        # Makes preemptive coordinate with coordGen() function,
        # then check it against a few special cases like "[]", "q", and "test" before proceeding with line gen
        temp = coordGen()

        # This works... But there must be a better way to retry a function besides recursion right?
        if temp == []:
           startPolygon(coordinateList, lineList)

        if temp == "q":
            lineGen(coordinateList, True)
            inputting = False

        # Prebuilt test polygon and test points, use desmos link as reference
        if temp == "prebuiltTest":
            coordinateList.extend([Coordinate(2, 6), Coordinate(4, 6), Coordinate(6, 5), Coordinate(8, 6), Coordinate(10, 6), Coordinate(8, 4), Coordinate(10, 2), Coordinate(6, 4), Coordinate(2, 2)])
            for i in coordinateList:
                print(i)
                # +1 instead of -1 would put them in the reverse (proper) order, but it shouldin't matter and cycling on index overflow would take more time
                lineList.append(Line(coordinateList[coordinateList.index(i)].x, coordinateList[coordinateList.index(i)].y, coordinateList[coordinateList.index(i) - 1].x, coordinateList[coordinateList.index(i) - 1].y, ""))
            inputting = False
        else:
            # Continues with line gen if none of the special cases trigger
            lineGen(temp, False)
    # While outside of polygon build mode (inside test mode)
    else:
        print("Input a positive coordinate as your test point")
        finalResult = pointChoose(coordinateList, lineList, temp)
        print(finalResult)
        # Testing stuff
        if (temp == "prebuiltTest"):
            if ((testPointIndex in [0, 1, 2, 3]) and (finalResult == "Outside")):
                startPolygon(coordinateList, lineList)
            if ((testPointIndex in [4, 5, 6, 7]) and (finalResult == "Inside")):
                startPolygon(coordinateList, lineList)
            else:
                print("Test Failed")
        else:
            if input("Choose another point? (Y)es or (N)o? ") == "y" or "Y":
                startPolygon(coordinateList, lineList)
            else:
                quit()

def pointChoose(coordinateList, lineList, temp):
    # Testing
    if (temp == "prebuiltTest"):
        testPoints = [Coordinate(4.65, 2.3333), Coordinate(2, 1.55), Coordinate(6.12, 3.7), Coordinate(10, 4), Coordinate(7, 4.5), Coordinate(7, 4), Coordinate(3.673, 5.23), Coordinate(9.5, 2.4) ]
        global testPointIndex
        testPointIndex = random.randint(0, 7)
        chosenPoint = (testPoints[testPointIndex])
    else:
        chosenPoint = coordGen()

    if chosenPoint == "q" or chosenPoint == []:
        print("Try again")
        # This fixes errors originating from recursion...
        retry = pointChoose(coordinateList, lineList, temp)
        return retry
    else:
        if (intersectionCheck(chosenPoint, coordinateList)):
            return "On vertex"
        
        if (intersectionCheck(chosenPoint, lineList)):
            return "On edge"

        # Don't run rayGen before we are certain chosen point is off edge or vertex
        bounds = BoundingBox(coordinateList)
        print(bounds.horizontalBounds) 
        print(bounds.verticalBounds)
        randomRay = rayGen(chosenPoint, bounds)

        if ((intersectionCheck(randomRay, lineList) % 2) == 0):
            return "Outside"

        if ((intersectionCheck(randomRay, lineList) % 2) != 0):
            return "Inside"

# "Escape rays" can be defined as a random slope value centered on the chosen point, with an inequality forcing the right direction
# Random slope value can be obtained by randomly choosing a number between -1 and +1 twice to create a new coordinate
# Then this coordinate and the original chosen point can have the slope equation applied, then inequality is applied
def rayGen(chosenPoint, bounds):
    signOffset = random.random()
    x_2 = chosenPoint.x + (random.random() - signOffset)
    y_2 = chosenPoint.y + (random.random() - signOffset)
    rayDirection = random.randint(0, 1)
    # y_1 and x_1 are zero, "origin", or if the chosen point then x_2 and y_2 are x_1 and y_1 plus offset
    randomRay = Line(chosenPoint.x, chosenPoint.y, x_2, y_2, rayDirection, bounds)
    if intersectionCheck(randomRay, coordinateList) == True:
        rayGen(chosenPoint, bounds)
    else:
        return randomRay

def intersectionCheck(individual, set):
    print(individual.__class__)
    # Checking what combination of individual and set classes, four possible combinations
    # Using the 0th index for the class of the object in the set... Not sure if there is a better way
    if individual.__class__ == set[0].__class__:

        if individual.__class__ == Coordinate:       
            for vertex in set:
                if (vertex.x == individual.x) and (vertex.y == individual.y):
                    return True

        if individual.__class__ == Line:
            count = 0;
            if individual.boundType == "x":
                for line in set:
                    # If individual == x but line == y
                    # Switch intercept and bounds when dealing with y boundsTypes
                    if line.boundType == "y":
                        tempY = individual.slope * line.intercept + individual.intercept
                        if ((individual.bounds[0] < line.intercept < individual.bounds[1]) or (individual.bounds[0] > line.intercept > individual.bounds[1])):
                            # Or makes sure the order dosen't matter
                            if (line.bounds[0] < tempY < line.bounds[1]) or (line.bounds[0] > tempY > line.bounds[1]):
                                count = count + 1
                    else:
                        # If they both have same type, same bounds, same slope, but different intercept
                        if ((individual.boundType == line.boundType) and (individual.bounds[0] == line.bounds[0]) and (individual.bounds[1] == line.bounds[1]) and (individual.intercept != line.intercept) and (individual.slope == line.slope)):
                            count = count
                        # If same everything
                        if ((individual.boundType == line.boundType) and (individual.bounds[0] == line.bounds[0]) and (individual.bounds[1] == line.bounds[1]) and (individual.intercept == line.intercept) and (individual.slope == line.slope)):
                            count = count + 1
                        else:
                            tempSlope = individual.slope - (line.slope)
                            tempIntercept = individual.intercept - (line.intercept)
                            # Makes sure lines don't overlap
                            try:
                                tempX = -tempIntercept / tempSlope
                            except ZeroDivisionError:
                                print("Don't overlap lines")
                                count = 100
                                return count

                            # Always 0, not used
                            tempY = tempSlope * tempX + tempIntercept

                            # Checks to make sure intersection point lies inside bounds, need not use equal sign because coordinates check will find that first
                            if (((individual.bounds[0] < tempX < individual.bounds[1]) or (individual.bounds[0] > tempX > individual.bounds[1])) and ((line.bounds[0] < tempX < line.bounds[1]) or (line.bounds[0] > tempX > line.bounds[1]))):
                                # Floating point error, Have to use tolerance
                                print("1: " + str(individual.slope * tempX + individual.intercept))
                                print("2: " + str(line.slope * tempX + line.intercept))
                                if (abs((individual.slope * tempX + individual.intercept) - (line.slope * tempX + line.intercept)) < 1e-9):
                                    count = count + 1
                            
                return count

            # Y bounds are simpler to handle
            if individual.boundType == "y":
                for line in set:
                    if line.boundType == "x":
                        tempY = line.slope * individual.intercept + line.intercept
                        if (individual.bounds[0] < tempY < individual.bounds[1]) or (individual.bounds[0] > tempY > individual.bounds[1]):
                            count = count + 1
                    else:
                        # Both are same but intercept, maybe this is redundant
                        if ((individual.boundType == line.boundType) and (individual.bounds[0] == line.bounds[0]) and (individual.bounds[1] == line.bounds[1]) and (individual.intercept != line.intercept) and (individual.slope == line.slope)):
                            count = count
                        if ((individual.boundType == line.boundType) and (individual.bounds[0] == line.bounds[0]) and (individual.bounds[1] == line.bounds[1]) and (individual.intercept == line.intercept) and (individual.slope == line.slope)):
                            count = count + 1
                        else:
                            # Both are y type equations and as such there is no possible intersection
                            count = count
                return count

    else:

        if (individual.__class__ == Coordinate):
             for line in set:
                # Is "<=" neccessary here? It shouldin't really matter because everything will get filtered above. 
                # And is incase bound order is wrong
                if ((line.boundType == "x") and ((line.bounds[0] <= individual.x <= line.bounds[1]) or (line.bounds[0] >= individual.x >= line.bounds[1]))):
                    if ((line.slope * individual.x + line.intercept) == individual.y):
                        return True
                if (line.boundType == "y") and ((line.bounds[0] <= individual.y <= line.bounds[1]) or (line.bounds[0] >= individual.y >= line.bounds[1])):
                    if (individual.x == line.intercept):
                        return True

        if individual.__class__ == Line:
            for vertex in set:
                if (individual.boundType == "x"):
                    # And part removes cases of endpoint on line touching vertex
                    if ((individual.slope * float(vertex.x) + individual.intercept == vertex.y) and ((individual.bounds[0] < vertex.x < individual.bounds[1]) or (individual.bounds[0] > vertex.x > individual.bounds[1]))):
                        return True
                if (individual.boundType == "y"):
                    if (float(vertex.x) == individual.intercept) and ((individual.bounds[0] < float(vertex.y) < individual.bounds[1]) or (individual.bounds[0] > float(vertex.y) > individual.bounds[1])):
                        return True
    
    return False


print("Input positive coordinates with space as delimeters like so; '2 3.45' for x = 2, y = 3.45 ")
print("When finished input 'q' (Minimum three coordinates)")
startPolygon(coordinateList, lineList)